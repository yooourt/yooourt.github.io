/*

作业 syntax.1


交作业目录
syntax/s1.gua


在这个作业中
我们要把嵌套数组解析出来



1, 解析普通数组
实现下面描述的 parse1 函数

下面的 s 是一个包含了 [ ] 字母 三种符号的字符串
var s = '[abc]'

这表示了一个 ['a', 'b', 'c'] 这样的数组

下面三行是示例
var l = parse1(s)
log(l)
// ['a', 'b', 'c']


编写逻辑如下

parse 里面逻辑如下
0，s 转成上课演示的 TokenList 对象实例 tl（群文件传了代码）
1，用 readToken() 看看，如果是 [ 就去调用 parseList1(tl)
2，parseList1 返回后就是处理好的数组了

parseList1(tl) 里面的逻辑如下
0，创建一个空数组 []
1，遇到普通 token 就 add
2，遇到 ] 就说明读完了







2, 解析嵌套数组
实现下面描述的 parse2 函数
var s = '[a[b]c]'

这表示了一个如下的数组
[
    'a',
    [
        'b',
    ],
    'c',
]


parse2 逻辑同上

parseList2(tl) 里面的逻辑如下
0，创建一个空数组 a
1，遇到普通 token 就 a.add
2，遇到 [ 就调用 parseList2(tl) 来解析出一个数组并 a.add
3，遇到 ] 就说明读完了，返回 a

以 [a[b]c] 这个例子来说明，下面是下标和字符对应关系
0123456
[a[b]c]

下面是程序执行的流程
parse2 拿到 tl
tl.readToken()
    得到 [，调用 parseList2
    这时候 tl.index 等于 1

parseList2 第一次调用
    readToken 得到 'a', 是普通 token, a.add 后 a = ['a']
    readToken 得到 '[', 调用 parseList2, 这时候 tl.index 等于 3 了
        在 parseList2 中 readToken 得到 'b'
        在 parseList2 中 readToken 得到 ']'，说明读完了，返回 ['b'], 这时候 tl.index 等于 5 了
    a.add 返回的内容也就是 ['b'], 现在 a = ['a', ['b']] 了
    readToken 得到 'c', 是普通 token, a.add 后 a = ['a', ['b'], 'c'] 了
    readToken 得到 ']', 说明读完了，返回 a 也就是 ['a', ['b'], 'c'] 了




3, 如果你作业 2 正确完成，应该可以直接解析下面的 s，试试
var s = "[abc[def[ghi]jkl]mno]"
var t = parse(s)

log(t)  // 输出如下


// [
//     'a',
//     'b',
//     'c',
//     [
//         'd',
//         'e',
//         'f',
//         [
//             'g',
//             'h',
//             'i',
//         ],
//         'j',
//         'k',
//         'l',
//     ],
//     'm',
//     'n',
//     'o',
// ]

*/

con isLetter = function(c) {
    var s = 'abcdefghijklmnopqrstuvwxyz'
    return s.find(c) > -1
}

con TokenType = {
    bracketLeft: 'bracketLeft',
    bracketRight: 'bracketRight',
    character: 'character',
}

con Token = class() {
    con new = function(value, type) {
        var this.value = value
        var this.type = type
    }
}

con TokenList = class() {
    con new = function(tokens) {
        var this.tokens = tokens
        var this.index = 0
    }

    con read = function() {
        var i = this.index
        this.index += 1
        if (i < this.tokens.length()) {
            return this.tokens[i]
        } else {
            return null
        }
    }

    con peek = function() {
        var i = this.index
        if (i < this.tokens.length()) {
            return this.tokens[i]
        } else {
            return null
        }
    }

    con empty = function() {
        return this.index >= this.tokens.length()
    }
}

con tokens = function(s) {
    var ts = []
    for (i, c in s) {
        if (isLetter(c)) {
            var t = Token.new(c, TokenType.character)
            ts.add(t)
        } else if (c == '[') {
            var t = Token.new(c, TokenType.bracketLeft)
            ts.add(t)
        } else if (c == ']') {
            var t = Token.new(c, TokenType.bracketRight)
            ts.add(t)
        } else {
            ensure(false, 'unexpected token {}'.format(c))
        }
    }
    return ts
}

con parseList = function(tl) {
    ensure(tl.read().type == TokenType.bracketLeft)

    var list = []
    while(not tl.empty()) {
        var token = tl.peek()
        if (token.type == TokenType.bracketRight) {
            tl.read()
            return list
        } else {
            var v = parse1(tl)
            list.add(v)
        }
    }
}

con parse1 = function(tl) {
    var token = tl.peek()
    if (token.type == TokenType.bracketLeft) {
        return parseList(tl)
    } else if (token.type == TokenType.character) {
        tl.read()
        return token.value
    } else {
        ensure(false, 'unexpected token {}'.format(token))
    }
}

con parse2 = parse1

con __main = function() {
    var s = "[abc[def[ghi]jkl]mno]"
    var ts = tokens(s)
    var tl = TokenList.new(ts)
    var p1 = parse2(tl)
    log('p2', p1)
}
